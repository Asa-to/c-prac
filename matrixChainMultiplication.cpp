#include<bits/stdc++.h>

using namespace std;

static const int N = 100;

//m[i][j]には、i～j番目までの行列のコストの最小値が入る。
int main(void){
    int n, p[N+1], m[N+1][N+1];
    cin >> n;
    //行列の行と列をpに入れる。i番目の行列の列とi+1番目の行列の行は同じ値なので同じ場所に入れてる
    for(int i = 1; i <= n; i++){
        cin >> p[i-1] >> p[i];
    }
    //i番目の行列とi番目の行列では計算が発生しないので0で初期化
    for(int i = 1; i <= n; i++)m[i][i] = 0;
    //連鎖行列積のコスト計算
    //lは対象とする行列の数を決めてる
    for(int l = 2; l <= n; l++){
        //i番目からj番目までの行列計算のコストを計算する。iとjはそのための変数
        //iは1番目の行列から、jが行列の存在する範囲を超えないようにi - l + 1番目までいく
        for(int i = 1; i <= n - l + 1; i++){
            //j = i + l だとi ~ jまでの範囲の行列の数が l + 1個になってしまうのでj = i + l - 1になっている。
            int j = i + l - 1;
            //めちゃ大きい値で初期化
            m[i][j] = (1 << 21);
            //i番目からj番目までの最小コストを計算する。
            //(M1M2M3M4M5)の最小コストは、例えば(M1M2M3)(M4M5)だとすると、このときkは3。で、(M1M2M3)は(M1M2)(M3)と(M1)(M2M3)の小さいほうの値で、もう入ってる。
            //(M4M5)は一通りのコストしかないので、OK。
            //この時 m[1][5] = (M1M2M3)のコスト + (M4M5)のコスト + (前半の計算でできる行列) × (後半の計算で出来る行列)のコスト(M1の行数 * M3の列数 * M5の列数)
            for(int k = i; k <= j - 1; k++){
                m[i][j] = min(m[i][j], m[i][k] + m[k + 1][j] + p[i-1] * p[k] * p[j]);
            }
        }
    }
    cout << m[1][n] << endl;
    return 0;
}